// Woeful_Wolf

local int colorSeed = 0xABCDEF;

int RandomColor() {
    colorSeed = (colorSeed * 1103515245 + 12345) & 0x7FFFFFFF;
    local int r = (colorSeed >> 16) & 0xFF;
    local int g = (colorSeed >> 8) & 0xFF;
    local int b = colorSeed & 0xFF;
    return (r << 16) | (g << 8) | b;  // Return as 0xRRGGBB
}

struct tpGxMeshData(tpGxMeshHead &meshHead) {
	local uint32 fileDataStart = FTell();
	local int i;
	local int k;

    FSeek(fileDataStart + meshHead.header.vertexBuffersOffset.offset);
	for (i = 0; i < meshHead.header.objectCount; i++) {
		struct (tpGxMeshHead &meshHead) {
			for (k = 0; k < meshHead.objects[i].vertexBufferCount; k++) {
				FSeek(fileDataStart + meshHead.objects[i].vertexBuffers[k].vertexBufferOffset);
				struct (tpGxMeshHead &meshHead){
					if (meshHead.objects[i].vertexBuffers[k].vertexBufferSize == 12) {
						if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == POSITION) {
							struct {
								float x;
								float y;
								float z;
							} positions[meshHead.objects[i].vertexCount];
						} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == WEIGHTS) {
							struct {
								float boneWeight0;
								float boneWeight1;
								float boneWeight2;
							} weights[meshHead.objects[i].vertexCount];
						} else {
							struct {
								float unknownFloats[3];
							} unknown[meshHead.objects[i].vertexCount];
						}
						
					} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferSize == 8) {
						if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == WEIGHTS) {
							struct {
								float boneWeight0;
								float boneWeight1;
							} weights[meshHead.objects[i].vertexCount];
						} else {
							struct {
								float unknownFloats[2];
							} unknown[meshHead.objects[i].vertexCount];
						}

					} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferSize == 4) {
						if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == NORMAL) {
							struct {
								byte nx;
								byte ny;
								byte nz;
								byte dummy;
							} normals[meshHead.objects[i].vertexCount];
                        } else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == COLOR) {
                            struct {
								ubyte r;
								ubyte g;
								ubyte b;
								ubyte a;
							} colors[meshHead.objects[i].vertexCount];
						} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == TANGENT) {
							struct {
								byte tx;
								byte ty;
								byte tz;
								byte bi;
							} tangents[meshHead.objects[i].vertexCount];
						} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == UV) {
							struct {
								hfloat u;
								hfloat v;
							} uvs[meshHead.objects[i].vertexCount];
						} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == BONES) {
							struct {
								ubyte boneIndex0;
								ubyte boneIndex1;
								ubyte boneIndex2;
								ubyte boneIndex3;
							} bones[meshHead.objects[i].vertexCount];
						} else {
							struct {
								ubyte unknownBytes[4];
							} unknown[meshHead.objects[i].vertexCount];
						}
					}
				} vertexBuffer(meshHead) <optimize=false>;
			}
			alignRelative(0, 4);
		} objectVertexBuffers(meshHead) <optimize=false>;
	}

	FSeek(fileDataStart + meshHead.header.indexBuffersOffset.offset);
	for (i = 0; i < meshHead.header.materialGroupCount; i++) {
		struct (tpGxMeshHead &meshHead){
			if (meshHead.objects[meshHead.materialGroups[i].objectIndex].indexBufferSize == 2) {
				struct {
					ushort v0;
					ushort v1;
					ushort v2;
				} loops[meshHead.materialGroups[i].indexCount/3] <optimize=false>;
			} else if (meshHead.objects[meshHead.materialGroups[i].objectIndex].indexBufferSize == 4) {
				struct {
					uint32 v0;
					uint32 v1;
					uint32 v2;
				} loops[meshHead.materialGroups[i].indexCount/3] <optimize=false>;
			}
		} materialGroupIndices(meshHead) <bgcolor=RandomColor(),optimize=false>;
	}
};