// Woeful_Wolf

struct tpGxMeshData(tpGxMeshHead &meshHead) {
	local uint32 fileDataStart = FTell();
	local int i;
	local int k;

    FSeek(fileDataStart + meshHead.header.vertexBuffersOffset.offset);
	for (i = 0; i < meshHead.header.objectCount; i++) {
		struct (tpGxMeshHead &meshHead) {
			for (k = 0; k < meshHead.objects[i].vertexBufferCount; k++) {
				FSeek(fileDataStart + meshHead.objects[i].vertexBuffers[k].vertexBufferOffset);
				struct (tpGxMeshHead &meshHead){
					if (meshHead.objects[i].vertexBuffers[k].vertexBufferSize == 12) {
						if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == POSITION) {
							struct {
								float x;
								float y;
								float z;
							} positions[meshHead.objects[i].vertexCount];
						} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == WEIGHTS) {
							struct {
								float boneWeight0;
								float boneWeight1;
								float boneWeight2;
							} weights[meshHead.objects[i].vertexCount];
						} else {
							struct {
								float unknownFloats[3];
							} unknown[meshHead.objects[i].vertexCount];
						}
						
					} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferSize == 8) {
						if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == WEIGHTS) {
							struct {
								float boneWeight0;
								float boneWeight1;
							} weights[meshHead.objects[i].vertexCount];
						} else {
							struct {
								float unknownFloats[2];
							} unknown[meshHead.objects[i].vertexCount];
						}

					} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferSize == 4) {
						if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == NORMAL) {
							struct {
								byte nx;
								byte ny;
								byte nz;
								byte dummy;
							} normals[meshHead.objects[i].vertexCount];
                        } else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == COLOR) {
                            struct {
								ubyte r;
								ubyte g;
								ubyte b;
								ubyte a;
							} colors[meshHead.objects[i].vertexCount];
						} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == TANGENT) {
							struct {
								byte tx;
								byte ty;
								byte tz;
								byte bi;
							} tangents[meshHead.objects[i].vertexCount];
						} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == UV) {
							struct {
								hfloat u;
								hfloat v;
							} uvs[meshHead.objects[i].vertexCount];
						} else if (meshHead.objects[i].vertexBuffers[k].vertexBufferType == BONES) {
							struct {
								ubyte boneIndex0;
								ubyte boneIndex1;
								ubyte boneIndex2;
								ubyte boneIndex3;
							} bones[meshHead.objects[i].vertexCount];
						} else {
							struct {
								ubyte unknownBytes[4];
							} unknown[meshHead.objects[i].vertexCount];
						}
					}
				} vertexBuffer(meshHead) <optimize=false>;
			}
			alignRelative(0, 4);
		} objectVertexBuffers(meshHead) <optimize=false>;
	}

	FSeek(fileDataStart + meshHead.header.indexBuffersOffset.offset);
	for (i = 0; i < meshHead.header.objectCount; i++) {
		struct (tpGxMeshHead &meshHead){
			for (k = 0; k < meshHead.objects[i].indexCount/3; k++) {
				if (meshHead.objects[i].indexBufferSize == 2) {
					struct {
						ushort v0;
						ushort v1;
						ushort v2;
					} loop;
				} else if (meshHead.objects[i].indexBufferSize == 4) {
					struct {
						uint32 v0;
						uint32 v1;
						uint32 v2;
					} loop;
				}
			}
			alignRelative(0, 4);
		} objectIndices(meshHead) <optimize=false>;
	}
};