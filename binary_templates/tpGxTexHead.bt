// Woeful_Wolf
// Yretenai

typedef  enum <uint32> {
	UNKNOWN = 0,
	R8G8B8A8_UNORM_STRAIGHT= 0x00010700,
	R8G8B8A8_UNORM = 0x00010800,
	R8G8B8A8_UNORM_SRGB = 0x00010B00,
	BC1_UNORM = 0x00010F00,
	BC1_UNORM_SRGB = 0x00011000,
	BC2_UNORM = 0x00011100,
	BC2_UNORM_SRGB = 0x00011200,
	BC3_UNORM = 0x00011300,
	BC3_UNORM_SRGB = 0x00011400,
	BC4_UNORM = 0x00011500,
	BC5_UNORM = 0x00011600,
	BC7_UNORM = 0x00011900,
	R32G32B32A32_FLOAT = 0x00030000,
	UNKN_A8_UNORM = 0x00031700,
} XonSurfaceDXGIFormat;

typedef struct {
	struct {
		uint32 texWidth;
		uint32 texHeight;

		uint32 texDepth;
		uint32 numSurfaces; // 1 for 2d, 6 for cubemaps

		uint32 texSize;

		uint32 unk2; // always 2147483648 (2**31)
		XonSurfaceDXGIFormat XonSurfaceFormat;

		uint32 numMipSurfaces;
		local uint32 mipSurfaceStartOffset = FTell();
		uint32 offsetToMipSurface;
	} header;

	FSeek( header.mipSurfaceStartOffset + header.offsetToMipSurface );
    
    // First mipsurface is always aligned 16 bytes to the start of the tpGxTexHead.header
    
	struct {
		uint32 offset; // From texData
        uint32 unk3; // always 0
        uint32 rowPitch;
        uint32 unk4; // always 0
        uint32 size;
        uint32 unk5; // always 0
        uint32 width;
        uint32 height;
        uint32 currentDepth;
        uint32 heightInBlocks;
	} mipSurface[header.numMipSurfaces];
} tpGxTexHead;

