// Woeful_Wolf

typedef enum <byte> {
    POSITION = 0,
    NORMAL = 1,
    TANGENT = 2,
    COLOR = 3,
    UV = 4,
    BONES = 5,
    WEIGHTS = 6
} VertexBufferType;

typedef struct {
	struct {
		struct {
			float x;
			float y;
			float z;
		} boundingBoxCoord1;
		struct {
			float x;
			float y;
			float z;
		} boundingBoxCoord2;
		uint32	totalVertexBuffersSize;
		DataOffset  vertexBuffersOffset;
		uint32	totalIndexBuffersSize;
		DataOffset  indexBuffersOffset;
		float unknownFloat;
		uint32	boneCount;
		local uint32 bonesStartOffset = FTell();
		uint32	offsetToBones;
		uint32 	bonePoseCount;
		local uint32 bonePosesStartOffset = FTell();
		uint32	offsetToBonePoses;
		uint32 	objectCount;
		local uint32 objectsStartOffset = FTell();
		uint32	offsetToObjects;
		uint32 	materialCount;
		local uint32 materialsStartOffset = FTell();
		uint32	offsetToMaterials;
		uint32 	materialGroupCount;
		local uint32 materialGroupsStartOffset = FTell();
		uint32	offsetToMaterialGroups;
	} header;

	FSeek( header.bonesStartOffset + header.offsetToBones );
	struct {
		local uint32 nameStartOffset = FTell();
		uint32  offsetToName;
		local uint32 returnPos = FTell();
		FSeek(nameStartOffset + offsetToName);
		string name;
		FSeek(returnPos);
		int32	parentBoneIndex;
		struct {
			float x;
			float y;
			float z;
			float w;
		} rotation;
		struct {
			float x;
			float y;
			float z;
		} scale;
		struct {
			float x;
			float y;
			float z;
		} position;
	} bones[header.boneCount] <optimize=false>;

	FSeek( header.bonePosesStartOffset + header.offsetToBonePoses );
	struct {
		local uint32 nameStartOffset = FTell();
		uint32  offsetToName;
		local uint32 returnPos = FTell();
		FSeek(nameStartOffset + offsetToName);
		string name;
		FSeek(returnPos);
		int32	unknownIndex;
		float	length;
		float   unknownMatrix0[16];
		float   unknownMatrix1[16];
	} bonePoses[header.bonePoseCount] <optimize=false>;

	FSeek( header.objectsStartOffset + header.offsetToObjects );
	struct {
		uint32  indicesStartOffset;
		uint32  unknownUInt32_1;
		uint32  unknownUInt32_2;
		uint32  vertexCount;
		uint32  indexCount;
		uint32  indexBufferSize;
		uint32  unknownUInt32_6;
		uint32  vertexBufferCount;
		local uint32 vertexBuffersStartOffset = FTell();
		uint32  offsetToVertexBuffers;
		
		local uint32 returnPos = FTell();
		FSeek(vertexBuffersStartOffset + offsetToVertexBuffers);
		struct {
			uint32  vertexBufferOffset;
			uint32  unknownUInt32_1;
			uint32  vertexBufferFlag;
			uint32  vertexBufferSize;
			VertexBufferType	vertexBufferType;
			alignRelative(0, 8);
		} vertexBuffers[vertexBufferCount] <optimize=false>;

		FSeek(returnPos);
		alignRelative(0, 8);
	} objects[header.objectCount] <optimize=false>;

	FSeek( header.materialsStartOffset + header.offsetToMaterials );
	struct {
		local uint32 nameStartOffset = FTell();
		uint32 offsetToName;
		local uint32 unknownStringStartOffset = FTell();
		uint32 offsetToUnknownString;
		uint32 maxBoneCount;
		local uint32 returnPos = FTell();
		FSeek(nameStartOffset + offsetToName);
		string name;
		FSeek(unknownStringStartOffset + offsetToUnknownString);
		string unknownString;
		FSeek(returnPos);
	} materials[header.materialCount] <optimize=false>;

	FSeek( header.materialGroupsStartOffset + header.offsetToMaterialGroups );
	struct {
		uint32 objectIndex;
		uint32 materialIndex;
		uint32 indexStart;
		uint32 indexCount;
		struct {
			float x;
			float y;
			float z;
		} boundingBoxCoord1;
		struct {
			float x;
			float y;
			float z;
		} boundingBoxCoord2;
	} materialGroups[header.materialGroupCount] <optimize=false>;
} tpGxMeshHead;