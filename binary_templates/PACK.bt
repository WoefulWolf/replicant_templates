// Woeful_Wolf
// Yretenai

void alignRelative(int relativeStart, int alignment) {
    local uint32 alignOffset = (((FTell() - relativeStart) / alignment) + 1) * alignment;
    FSeek(relativeStart + alignOffset);
}

struct DataOffset {
    uint offset   : 31; 
    uint has_data : 1;  
};

struct Import {
    uint32  pathHash<format=hex>; // FNV-1
    local uint32 pathStartOffset = FTell();
    uint32  offsetToPath;
    uint32  unknown0;
    local uint returnPos = FTell();
    FSeek(pathStartOffset + offsetToPath);
    string path;
    FSeek(returnPos);
};

#include "tpGxMeshAssetV2.bt"
#include "tpGxMaterialInstanceV2.bt"
#include "tpActorAssetParam.bt"
#include "tpXonAssetHeader.bt"
#include "tpGxMeshHead.bt"

#include "tpGxMeshData.bt"

#include "tpGxTexHead.bt"
#include "tpGxTexData.bt"

#include "tpTandaFontSdfParam.bt"
#include "tpArchiveFileParam.bt"
#include "WeaponSpecPackage.bt"
#include "OptionSettingItemListParam.bt"
#include "WidgetParam.bt"

struct {
    char    magic[4];
    uint32  version;
    uint32  packTotalSize;
    uint32  packSerializedSize;
    uint32  packFilesDataSize;
    uint32  importsCount;
    local uint32 importsStartOffset = FTell();
    uint32  offsetToImports;
    uint32  assetPackagesCount;
    local uint32 assetPackagesStartOffset = FTell();
    uint32  offsetToAssetPackages;
    uint32  filesCount;
    local uint32 filesStartOffset = FTell();
    uint32  offsetToFiles;
} header;

if (header.importsCount != 0) {
    FSeek( header.importsStartOffset + header.offsetToImports );
    Import imports[header.importsCount] <optimize=false, read=ReadImport>;
}

if (header.assetPackagesCount != 0) {
    FSeek( header.assetPackagesStartOffset + header.offsetToAssetPackages );
    struct AssetPackage {
        uint32  nameHash<format=hex>;
        local uint32 nameStartOffset = FTell();
        uint32  offsetToName;
        uint32  contentSize;
        local uint32 contentStartOffset = FTell();
        uint32  offsetToContentStart;
        uint32  offsetToContentEnd;
        FSeek(nameStartOffset + offsetToName);
        string name;
        FSeek( contentStartOffset + offsetToContentStart );
        #include "BXON.bt"
    } assetPackages[header.assetPackagesCount] <optimize=false, read=ReadAssetPackage>;
}

if (header.filesCount != 0) {
    FSeek( header.filesStartOffset + header.offsetToFiles );
    struct File {
        uint32 nameHash <format=hex>; // FNV-1
        local uint32 nameStartOffset = FTell();
        uint32 offsetToName;
        uint32 contentSize;
        local uint32 contentStartOffset = FTell();
        uint32  offsetToContent;
        DataOffset dataOffset;

        local uint32 returnPos = FTell();
        FSeek(nameStartOffset + offsetToName);
        string name;  
        FSeek(contentStartOffset + offsetToContent);
        char id[4] <hidden=true>;
        FSkip(-4);
            if (id == "BXON") {
                #include "BXON.bt"
            } else if (id == "CJF\x01") {
                #include "CJF.bt"
            } else if (id == "KPK\x7F" || id == "KPKy") {
                #include "KPKy.bt"
            } else if (id == "ITD\x00") {
                #include "ITDLL.bt"
            }

        FSeek(returnPos);
    } files[header.filesCount] <optimize=false, read=ReadFile>;

    if (header.packFilesDataSize != 0) {
	    local int i;
        struct {
	    for (i = 0; i < header.filesCount; i++) {
	        if (files[i].dataOffset.has_data) {
                FSeek(header.packSerializedSize + files[i].dataOffset.offset);
	        	if (files[i].content.assetType == "tpGxMeshHead") {
		            tpGxMeshData meshData(files[i].content.meshHead);
		        } else if (files[i].content.assetType == "tpGxTexHead") {
		        	tpGxTexData texData(files[i].content.texHead);
		        }

            }
	    }
        } filesData <optimize=false>;
    }
 }
 
string ReadAssetPackage(AssetPackage &ap) {
    return ap.name;
}

string ReadImport(Import &i) {
    return i.path;
}

string ReadFile(File &f) {
    return f.name;
}