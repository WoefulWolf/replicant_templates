// Woeful_Wolf
// Yretenai

void alignRelative(int relativeStart, int alignment) {
    local uint32 alignOffset = (((FTell() - relativeStart) / alignment) + 1) * alignment;
    FSeek(relativeStart + alignOffset);
}

void alignRelative2(int relativeStart, int alignment) {
	local uint32 v = relativeStart % alignment;
	if (v != 0) {
		FSeek(relativeStart + alignment - v);
	}
}

#include "tpXonAssetHeader.bt"

#include "tpGxMeshHead.bt"
#include "tpGxMeshData.bt"

#include "tpGxTexHead.bt"
#include "tpGxTexData.bt"

#include "tpTandaFontSdfParam.bt"
#include "tpArchiveFileParam.bt"

struct {
    char    magic[4];
    uint32  version;
    uint32  packTotalSize;
    uint32  packSerializedSize;
    uint32  packFilesDataSize;
    uint32  importsCount;
    local uint32 importsStartOffset = FTell();
    uint32  offsetToImports;
    uint32  assetPackagesCount;
    local uint32 assetPackagesStartOffset = FTell();
    uint32  offsetToAssetPackages;
    uint32  filesCount;
    local uint32 filesStartOffset = FTell();
    uint32  offsetToFiles;
} header;

if (header.importsCount != 0) {
    FSeek( header.importsStartOffset + header.offsetToImports );
    struct {
        uint32  pathHash<format=hex>; // FNV-1
        local uint32 pathStartOffset = FTell();
        uint32  offsetToPath;
        uint32  unknown0;
        local uint returnPos = FTell();
        FSeek(pathStartOffset + offsetToPath);
        string path;
        FSeek(returnPos);
    } imports[header.importsCount] <optimize=false>;
}

if (header.assetPackagesCount != 0) {
    FSeek( header.assetPackagesStartOffset + header.offsetToAssetPackages );
    struct {
        uint32  nameHash<format=hex>;
        local uint32 nameStartOffset = FTell();
        uint32  offsetToName;
        uint32  contentSize;
        local uint32 contentStartOffset = FTell();
        uint32  offsetToContentStart;
        uint32  offsetToContentEnd;
        FSeek(nameStartOffset + offsetToName);
        string name;
        FSeek( contentStartOffset + offsetToContentStart );
        #include "BXON.bt"
    } assetPackages[header.assetPackagesCount] <optimize=false>;
}

if (header.filesCount != 0) {
    FSeek( header.filesStartOffset + header.offsetToFiles );
    struct DataOffset {
        uint offset   : 31; 
        uint has_data : 1;  
    };
    struct {
        uint32 nameHash <format=hex>; // FNV-1
        local uint32 nameStartOffset = FTell();
        uint32 offsetToName;
        uint32 contentSize;
        local uint32 contentStartOffset = FTell();
        uint32  offsetToContent;
        DataOffset dataOffset;

        local uint32 returnPos = FTell();
        FSeek(nameStartOffset + offsetToName);
        string name;  
        FSeek(contentStartOffset + offsetToContent);
        char id[4] <hidden=true>;
        FSkip(-4);
        if (id == "BXON") {
            #include "BXON.bt"
        } else if (id == "CJF") {
            #include "CJF.bt"
        } else if (id == "KPK") {
            #include "KPKy.bt"
        }

        FSeek(returnPos);
    } files[header.filesCount] <optimize=false>;

    if (header.packFilesDataSize != 0) {
	    local int i;
        struct {
	    for (i = 0; i < header.filesCount; i++) {
	        if (files[i].dataOffset.has_data) {
                FSeek(header.packSerializedSize + files[i].dataOffset.offset);
	        	if (files[i].content.assetType == "tpGxMeshHead") {
		            tpGxMeshData meshData(files[i].content.meshHead);
		        } else if (files[i].content.assetType == "tpGxTexHead") {
		        	tpGxTexData texData(files[i].content.texHead);
		        }
            }
	    }
        } filesData <optimize=false>;
    }
 }
